Datos del proyecto:
Tipo de aplicacion --> API Rest


Estructura del proyecto:
    config/ --> datos de configuracion de la BBDD (Archivos de paso 1º y 2º)
    models/ --> modelos/clases de nuestras entidades de datos (Archivos de paso 2º)
    router/ --> Sistema de enrutado
    schemas/ --> esquemas de validacion de las requests

Tecnologias usadas :
    BBDD : postgres con driver psycopg2
    Framework : fastapi
    Sistema ORM : sqlalchemy 
    validacion : libreria pydantic
    Constantes usadas por toda la aplicacion : libreria python-dotenv

Flujo de trabajo en Git:
    1º Rama API --> API Rest entregable + testing
    2º Rama developer --> Desarrollo de API Rest con enrutado + validaciones (schemas)
    2º Rama BBDD --> Modelado de datos, configuracion de conexion BBDD  y creacion de clases para mapeo
    3º Rama docs --> Generacion de documentacion del proyecto
    4º gitignore --> gitignore.io : archivos .env, archivos de datos csv y excel y archivos

Analisis de modelo de negocio:
    Operaciones permitidas con nuestra API
    Significado de cada entidad-tabla
    Limpieza de los datos en csv
    Analisis de datos:
        PRODUCTO:

        SKU = id de cada producto
        Name = nombre del producto
        Price = precio
        Description = descripcion del producto
        Track inventory = seguimiento del inventario
        QTY = cantidad del inventario
        Weight = peso (del telefono)
        Length = longitud (del telefono)
        Width = ancho (del telefono)
        Height = altura (del telefono)
        Image URL = URL de la imagen
        SEO Tittle = meta titulos (etiqueta para posicionar una pagina web)
        SEO Description = meta descripcion (descripcion de los algoritmos de los motores de busqueda)
        Color = color del telefono
        Status_id = estado del telefono
        Category_id = modelo del telefono
        Memory_id = capacidad de memoria del telefono

        ORDERS

1º Externalizacion de datos de conexion de BBDD --> libreria python-dotenv y archivo config.py
    a) Crear archivo .env --> Datos sensibles almacenados en constantes con formato CLAVE=valor
    b) Creacion de clase Settings , cuyos atributos son los datos de la conexion a la BBDD --> Lectura de variables de entorno de archivo .env
    c) creacion de URL de conexion para ser importada en archivo db_config.py

2º Creacion de conexion de BBDD con O.R.M SQLAlchemy en archivo db_config.py
    a) Creacion del engine : manejo de conexiones a BBDD y conversion del dialecto propio de BBDD 
    b) Creacion  objeto sessionmarker : Ejecucion de transacciones sobre BBDD
    c) Creacion de objeto de clase Base --> Todas las clases que la hereden seran mapeadas por el ORM de forma automatica

3º) Modelado de datos de acuerdo a nuestra logica de negocio :
    a) Diseño del modelo de datos mediante Esquema UML --> modelo relacional a traves diagrama entidad relacion, definiendo entidades y sus relaciones 
    b) Documentacion de la logica de negocio y significado de cada atributo
    c) Creacion del archivo models.py , donse se declaran las clases resultantes del paso a (las entidades del DER)
    d) Clases - Entidades : __tablename__ , atributos  y metodos __init__, __repr__ y __str__. La relaciones que se establecen segun el DER son:
        Relacion 1 - 1
        Relacion 1-n : foreign key del lado de N
        Relacion n-m : tabla intermedia con claves primarias de cada una de las tablas relacionadas y atributos de la relacion, en caso de que los hubiera.
    e) relationship : atributos de cada clase que establecen relacion con un atributo (indicado por back_populates) de otra clase--> La vinculacion con relationship se hace en ambas tablas
    f) Mapeo objeto relacional a traves del ORM de las clases del paso b --> Se usa objeto Base y el mapeo se realiza a traves del engine creado en 2a) que contiene la conexion a la BBDD
    g) Elegir metodo de borrado(ON DELETE) para mantener de datos mediante restricciones de integridad referencial(parametro de relationship):
        RESTRICT: Es el comportamiento por defecto, que impide realizar modificaciones que atentan contra la integridad referencial.
        CASCADE: Borra los registros de la tabla dependiente cuando se borra el registro de la tabla principal (en una sentencia DELETE), 
                o actualiza el valor de la clave secundaria cuando se actualiza el valor de la clave referenciada (en una sentencia UPDATE).
        SET NULL: Establece a NULL el valor de la clave secundaria cuando se elimina el registro en la tabla principal o se modifica el valor del campo referenciado.
        NO ACTION : similar a RESTRICT
    h) importacion de datos de csv a tablas de BBDD:
        1) Convertir csv a excel con libreria pandas
        2) Tratamiento de datos nulos
        3) Limpieza y transformaciones de datos en el archivo excel para que sean compatibles con tablas SQL (Formato de columnas excel == formato de columnas tablas de BBDD)
        4) Insertar datos de archivos excel como registros de cada tabla -->ejecutar una sola vez el archivo load_data.py

** HERRAMIENTA USADA PARA DER --> LUCIDCHART : https://lucid.app/lucidchart/42164ee5-5da6-4273-b8fc-bcc3253da97b/edit?viewport_loc=89%2C-339%2C2313%2C1033%2C0_0&invitationId=inv_9f050050-b484-4aa4-a22f-fab61eebddd7
4º) Definir operaciones soportadas con api:
    a) Productos :
        Crear producto --> Verificar Fks valida antes de agregar producto
        Actualizar campos del producto
        Obtener un producto, segun sku
        Obtener lista de todos los productos
        Obtener rango de productos
    b) Create de tabla orders --> Request cumple schema orders -->Verifica que id producto exista, crea cliente y crea order --> actualiza tabla product_orders
        Crear 
4º) Creacion de esquemas de validacion -->Valida Request de peticion http y respuesta (Response)
        En archivos schemas.py se definen los esquemas (clases) , las cuales extienden de la superclase BaseModel de la libreria pydantic-->
             -  Todas las variables que definamos dentro de la clase que extienda de BaseModel,
                pasará por un proceso de validación y si hay algún error lanzará una excepción.
            - Field nos permite validar distintos tipos de datos, marcar si es obligatorio o no, tamaños máximos y mínimos, etc.
            - La clase EmailStr permite tipar una variable como tipo email y validará si el email recibido es válido o no.    
            - Cada clasedatta o esquema contiene los atributos que puede(Opcional)/debe (obligatorio) contener el body de la request y su respectivo tipo de dato
        a) Product_create (Con campos obligatorios) y Product_update(Con campos opcionales) --> schemas de requests 
        b) orders
        c) customer 
5º Crear sistema de enrutado con APIRouter de fastapi --> Enrutado para operaciones CRUD de products y orders : operaciones permitidas para el cliente

6º) Creacion de capa servicios (carpeta services) --> operaciones auxiliares(metodos) que son usadas por metodos CRUD
    - products_services: validacion de valores de FKs enviadas en peticion HTTP de creacion y actualizacion producto
    - Validacion de FKs
    - Al obtener productos -- utilizar operacion join de tabla productos con tablas relacionadas de status, memory y categories
    - Obtencion de producto por sku

    -Orders:
        Verificar existencia de producto
        Crear cliente
        Actualizar datos del cliente
        Actualizar tabla intermedia product-order con tupla de id_product/id_order y lso datos de cantidad y metodo de pago

    -Orders:

7ª) DTO de order (pedido):
    - 
    - Order : Datos del pedido
    - data:lista de productos incluidos en order que incluye producto + cantidad + metodo de pago
    -   Customer :datos del cliente que hizo el pedido

8º Crear rutas para operaciones soportadas por la API:
    Importar esquemas de validacion hechas con pydantic --> validaremos los body de las requests (Peticiones http) en base a estos esquemas 
    Importar objeto sessionmarker , a traves del cual realizaremos las queries necesarias para cada operacion (transaccion )
    Concepto de transaccion: Conjunto de operaciones que se ejecutan exitosamente en conjunto o no se ejecuta ninguna
    Importar los modelos de datos definidos en archivo models.py
    Definir rutas para operaciones CRUD basicas sobre entidad products y orders con APIRouter() en incluir los enrutados en app.py con include_router():
        Usar decoradores para cada metodo que gestione una ruta : especificar instancia de APIRouter + verbo http y parametros como response_model, status_code y tags si fueran necesarios
        Products: obtener todos los productos, obtener producto por id, obtener rango de productos, crear producto, actualizar producto y borrar producto




        Crear orders --> Informacion necesaria: datos de cliente y productos
                        Tareas necesarias para creacion de producto:
                            - Verificar que exista producto y tenga existencias suficientes en inventario
                            - Crear cliente , en caso de que no exista (verificar si existe cliente)
                            - order_date es la fecha actual desde que se ejecuto la peticion post correctamente
                            - calcular importe total del pedido, recorriendo los productos , en base a la cantidad de cada producto del pedido
    Validar las peticiones entrantes : los datos del body para que sean coherentes y gestionar las situaciones donde el tipo de dato del campo sea correcto pero el valor de ese campo es incorrecto
    Utilizar metodos de la capa de servicios
    Response --> Seleccionar datos del producto que deben ser mostrados
    Serializar respuestas con JSONResponse y status_codes de fastapi

9º Definir excepciones y manejo de errores en cada operacion soportada por API Rest:
    Usar HttpException para lanzar excepciones en caso de errores
    Usar try catch para captura de excepciones y metodo rollback en caso de que la transaccion no se ejecute correctamente
10º) Autenticacion:
    librería passlib con el algoritmo de Bcrypt
    Creacion de schemas en schemas/auth_schema
    Uso de libreria pyjwt para codificar y decodificar token del estandar JWT

Enlaces de consulta:
https://platzi.com/tutoriales/2514-fastapi-modularizacion-datos/12196-apirouter-para-modularizacion-del-proyecto/
https://es.stackoverflow.com/questions/105890/qué-significa-cascade-set-null-restrict-no-action-en-mysql
Join :
https://es.stackoverflow.com/questions/24814/join-en-sqlalchemy

ERRORES:

Busqueda de objetos: filtrar por condicion(filter) y obtener primer elemento con metodo first() --> Error de timeout sin first(), por mas que sea un solo objeto que coincida con la nusqueda
En transacciones de create y update --> Incluir session.rollback ante fallos y siempre cerrar la sesion con close(), tanto ante una excepcion como al finalizar exitosamente transaccion

PENDIENTES:
Crear correctamente DTO como request de operacion GET de todos los productos