Datos del proyecto:
Tipo de aplicacion --> API Rest

Estructura del proyecto:
    config/ --> datos de configuracion de la BBDD (Archivos de paso 1º y 2º)
    models/ --> modelos/clases de nuestras entidades de datos (Archivos de paso 2º)
    router/ --> Sistema de enrutado
    schemas/ --> esquemas de validacion de las requests

Tecnologias usadas :
    BBDD : postgres con driver psycopg2
    Framework : fastapi
    Sistema ORM : sqlalchemy 
    validacion : libreria pydantic
    Constantes usadas por toda la aplicacion : libreria python-dotenv

Flujo de trabajo en Git:
    1º Rama API --> API Rest entregable + testing
    2º Rama developer --> Desarrollo de API Rest con enrutado + validaciones (schemas)
    2º Rama BBDD --> Modelado de datos, configuracion de conexion BBDD  y creacion de clases para mapeo
    3º Rama docs --> Generacion de documentacion del proyecto
    4º gitignore --> gitignore.io : archivos .env, archivos de datos csv y excel y archivos

Analisis de modelo de negocio:
    Operaciones permitidas con nuestra API
    Significado de cada entidad-tabla
    Limpieza de los datos en csv
    Analisis de cada atributo

1º Externalizacion de datos de conexion de BBDD --> libreria python-dotenv y archivo config.py
    a) Crear archivo .env --> Datos sensibles almacenados en constantes con formato CLAVE=valor
    b) Creacion de clase Settings , cuyos atributos son los datos de la conexion a la BBDD --> Lectura de variables de entorno de archivo .env
    c) creacion de URL de conexion para ser importada en archivo db_config.py

2º Creacion de conexion de BBDD con O.R.M SQLAlchemy en archivo db_config.py
    a) Creacion del engine : manejo de conexiones a BBDD y conversion del dialecto propio de BBDD 
    b) Creacion  objeto sessionmarker : Ejecucion de transacciones sobre BBDD
    c) Creacion de objeto de clase Base --> Todas las clases que la hereden seran mapeadas por el ORM de forma automatica

3º) Modelado de datos de acuerdo a nuestra logica de negocio :
    a) Diseño del modelo de datos mediante Esquema UML --> modelo relacional a traves diagrama entidad relacion, definiendo entidades y sus relaciones 
    b) Documentacion de la logica de negocio y significado de cada atributo
    c) Creacion del archivo models.py , donse se declaran las clases resultantes del paso a (las entidades del DER)
    d) Clases - Entidades : __tablename__ , atributos  y metodos __init__, __repr__ y __str__. La relaciones que se establecen segun el DER son:
        Relacion 1 - 1
        Relacion 1-n : foreign key del lado de necesario
        Relacion n-m : tabla intermedia con claves primarias de cada una de las tablas relacionadas
    e) relationship : atributos que establecen relacion con un atributo en particular(indicado por back_populates) de otra tabla --> La vinculacion con relationship se hace en ambas tablas
    f) Mapeo objeto relacional a traves del ORM de las clases del paso b --> Se usa objeto Base y el mapeo se realiza a traves del engine creado en 2a) que contiene la conexion a la BBDD
    g) importacion de datos de csv a tablas de BBDD:
        1) Convertir csv a excel con libreria pandas
        2) Tratamiento de datos nulos
        3) Limpieza y transformaciones de datos en el archivo excel para que sean compatibles con tablas SQL (Formato de columnas excel == formato de columnas tablas de BBDD)
        4) Insertar datos de archivos excel como registros de cada tabla -->ejecutar una sola vez el archivo load_data.py

** HERRAMIENTA USADA PARA DER --> LUCIDCHART : https://lucid.app/lucidchart/42164ee5-5da6-4273-b8fc-bcc3253da97b/edit?viewport_loc=89%2C-339%2C2313%2C1033%2C0_0&invitationId=inv_9f050050-b484-4aa4-a22f-fab61eebddd7
4º) Definir operaciones soportadas con api:
    a) Create de tabla orders --> Request cumple schema orders -->Verifica que id producto exista, crea cliente y crea order --> actualiza tabla product_orders

4º) Creacion de esquemas de validacion -->Valida Request de peticion http y respuesta (Response)
        En archivos schemas.py se definen los esquemas (clases) , las cuales extienden de la superclase BaseModel de la libreria pydantic
        Cada clasedatta o esquema contiene los atributos que puede(Opcional)/debe (obligatorio) contener el body de la request y su respectivo tipo de dato
        a) Product_create (Con campos obligatorios) y Product_update(Con campos opcionales) --> schemas de requests 
        b) orders
        c) customer 
5º Crear sistema de enrutado con APIRouter de fastapi --> Enrutado para operaciones CRUD de products y orders : operaciones permitidas para el cliente

6º) Creacion de capa servicios (carpeta services) --> operaciones auxiliares(metodos) que son usadas por metodos CRUD
    - products_services: validacion de valores de FKs enviadas en peticion HTTP de creacion y actualizacion producto
    - Validacion de FKs
    - Al obtener productos -- utilizar operacion join de tabla productos con tablas relacionadas de status, memory y categories
    - Obtencion de producto por sku

7º Crear rutas para operaciones soportadas por la API:
    Importar esquemas de validacion hechas con pydantic --> validaremos los body de las requests (Peticiones http) en base a estos esquemas 
    Importar objeto sessionmarker , a traves del cual realizaremos las queries necesarias para cada operacion (transaccion )
    Concepto de transaccion: Conjunto de operaciones que se ejecutan exitosamente en conjunto o no se ejecuta ninguna
    Importar los modelos de datos definidos en archivo models.py
    Definir rutas para operaciones CRUD basicas sobre entidad products y orders con APIRouter():
        Usar decoradores para cada metodo que gestione una ruta : especificar instancia de APIRouter + verbo http y parametros como response_model, status_code y tags si fueran necesarios
        Products: obtener todos los productos, obtener producto por id, obtener rango de productos, crear producto, actualizar producto y borrar producto
        Orders --> Pendiente
    Validar las peticiones entrantes : los datos del body para que sean coherentes y gestionar las situaciones donde el tipo de dato del campo sea correcto pero el valor de ese campo es incorrecto
    Utilizar metodos de la capa de servicios
    Serializar respuestas con JSONResponse y status_codes de fastapi

7º Definir excepciones y manejo de errores en cada operacion soportada por API Rest:
    Usar HttpException para lanzar excepciones en caso de errores
    Usar try catch para captura de excepciones y metodo rollback en caso de que la transaccion no se ejecute correctamente

Enlaces de consulta:
https://platzi.com/tutoriales/2514-fastapi-modularizacion-datos/12196-apirouter-para-modularizacion-del-proyecto/

Join :
https://es.stackoverflow.com/questions/24814/join-en-sqlalchemy

ERRORES:

Busqueda de objetos: filtrar por condicion(filter) y obtener primer elemento con metodo first() --> Error de timeout sin first(), por mas que sea un solo objeto que coincida con la nusqueda
En transacciones de create y update --> Incluir session.rollback ante fallos y siempre cerrar la sesion con close(), tanto ante una excepcion como al finalizar exitosamente transaccion